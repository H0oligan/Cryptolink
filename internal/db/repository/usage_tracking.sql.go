// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: usage_tracking.sql

package repository

import (
	"context"
	"database/sql"
	"time"

	"github.com/jackc/pgtype"
)

const createUsageTracking = `-- name: CreateUsageTracking :one
INSERT INTO usage_tracking (
    merchant_id,
    period_start,
    period_end,
    payment_count,
    payment_volume_usd,
    api_calls_count,
    created_at,
    updated_at
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, merchant_id, period_start, period_end, payment_count, payment_volume_usd, api_calls_count, created_at, updated_at
`

type CreateUsageTrackingParams struct {
	MerchantID       int64
	PeriodStart      time.Time
	PeriodEnd        time.Time
	PaymentCount     sql.NullInt32
	PaymentVolumeUsd pgtype.Numeric
	ApiCallsCount    sql.NullInt32
	CreatedAt        time.Time
	UpdatedAt        time.Time
}

func (q *Queries) CreateUsageTracking(ctx context.Context, arg CreateUsageTrackingParams) (UsageTracking, error) {
	row := q.db.QueryRow(ctx, createUsageTracking,
		arg.MerchantID,
		arg.PeriodStart,
		arg.PeriodEnd,
		arg.PaymentCount,
		arg.PaymentVolumeUsd,
		arg.ApiCallsCount,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i UsageTracking
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.PaymentCount,
		&i.PaymentVolumeUsd,
		&i.ApiCallsCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCurrentPeriodUsage = `-- name: GetCurrentPeriodUsage :one
SELECT id, merchant_id, period_start, period_end, payment_count, payment_volume_usd, api_calls_count, created_at, updated_at FROM usage_tracking
WHERE merchant_id = $1
AND period_start <= $2
AND period_end >= $2
ORDER BY period_start DESC
LIMIT 1
`

type GetCurrentPeriodUsageParams struct {
	MerchantID  int64
	PeriodStart time.Time
}

func (q *Queries) GetCurrentPeriodUsage(ctx context.Context, arg GetCurrentPeriodUsageParams) (UsageTracking, error) {
	row := q.db.QueryRow(ctx, getCurrentPeriodUsage, arg.MerchantID, arg.PeriodStart)
	var i UsageTracking
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.PaymentCount,
		&i.PaymentVolumeUsd,
		&i.ApiCallsCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUsageTrackingByID = `-- name: GetUsageTrackingByID :one
SELECT id, merchant_id, period_start, period_end, payment_count, payment_volume_usd, api_calls_count, created_at, updated_at FROM usage_tracking
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetUsageTrackingByID(ctx context.Context, id int64) (UsageTracking, error) {
	row := q.db.QueryRow(ctx, getUsageTrackingByID, id)
	var i UsageTracking
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.PaymentCount,
		&i.PaymentVolumeUsd,
		&i.ApiCallsCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUsageTrackingByMerchantAndPeriod = `-- name: GetUsageTrackingByMerchantAndPeriod :one
SELECT id, merchant_id, period_start, period_end, payment_count, payment_volume_usd, api_calls_count, created_at, updated_at FROM usage_tracking
WHERE merchant_id = $1
AND period_start = $2
LIMIT 1
`

type GetUsageTrackingByMerchantAndPeriodParams struct {
	MerchantID  int64
	PeriodStart time.Time
}

func (q *Queries) GetUsageTrackingByMerchantAndPeriod(ctx context.Context, arg GetUsageTrackingByMerchantAndPeriodParams) (UsageTracking, error) {
	row := q.db.QueryRow(ctx, getUsageTrackingByMerchantAndPeriod, arg.MerchantID, arg.PeriodStart)
	var i UsageTracking
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.PaymentCount,
		&i.PaymentVolumeUsd,
		&i.ApiCallsCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const incrementAPIUsage = `-- name: IncrementAPIUsage :exec
UPDATE usage_tracking
SET
    api_calls_count = api_calls_count + $2,
    updated_at = NOW()
WHERE merchant_id = $1
AND period_start <= NOW()
AND period_end >= NOW()
`

type IncrementAPIUsageParams struct {
	MerchantID    int64
	ApiCallsCount sql.NullInt32
}

func (q *Queries) IncrementAPIUsage(ctx context.Context, arg IncrementAPIUsageParams) error {
	_, err := q.db.Exec(ctx, incrementAPIUsage, arg.MerchantID, arg.ApiCallsCount)
	return err
}

const incrementPaymentUsage = `-- name: IncrementPaymentUsage :exec
UPDATE usage_tracking
SET
    payment_count = payment_count + 1,
    payment_volume_usd = payment_volume_usd + $2,
    updated_at = NOW()
WHERE merchant_id = $1
AND period_start <= NOW()
AND period_end >= NOW()
`

type IncrementPaymentUsageParams struct {
	MerchantID       int64
	PaymentVolumeUsd pgtype.Numeric
}

func (q *Queries) IncrementPaymentUsage(ctx context.Context, arg IncrementPaymentUsageParams) error {
	_, err := q.db.Exec(ctx, incrementPaymentUsage, arg.MerchantID, arg.PaymentVolumeUsd)
	return err
}

const listUsageTrackingByMerchantID = `-- name: ListUsageTrackingByMerchantID :many
SELECT id, merchant_id, period_start, period_end, payment_count, payment_volume_usd, api_calls_count, created_at, updated_at FROM usage_tracking
WHERE merchant_id = $1
ORDER BY period_start DESC
LIMIT $2
`

type ListUsageTrackingByMerchantIDParams struct {
	MerchantID int64
	Limit      int32
}

func (q *Queries) ListUsageTrackingByMerchantID(ctx context.Context, arg ListUsageTrackingByMerchantIDParams) ([]UsageTracking, error) {
	rows, err := q.db.Query(ctx, listUsageTrackingByMerchantID, arg.MerchantID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsageTracking
	for rows.Next() {
		var i UsageTracking
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.PaymentCount,
			&i.PaymentVolumeUsd,
			&i.ApiCallsCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUsageTracking = `-- name: UpdateUsageTracking :exec
UPDATE usage_tracking
SET
    payment_count = $2,
    payment_volume_usd = $3,
    api_calls_count = $4,
    updated_at = NOW()
WHERE id = $1
`

type UpdateUsageTrackingParams struct {
	ID               int64
	PaymentCount     sql.NullInt32
	PaymentVolumeUsd pgtype.Numeric
	ApiCallsCount    sql.NullInt32
}

func (q *Queries) UpdateUsageTracking(ctx context.Context, arg UpdateUsageTrackingParams) error {
	_, err := q.db.Exec(ctx, updateUsageTracking,
		arg.ID,
		arg.PaymentCount,
		arg.PaymentVolumeUsd,
		arg.ApiCallsCount,
	)
	return err
}
