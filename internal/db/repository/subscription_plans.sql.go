// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: subscription_plans.sql

package repository

import (
	"context"
	"database/sql"

	"github.com/jackc/pgtype"
)

const getSubscriptionPlanByID = `-- name: GetSubscriptionPlanByID :one
SELECT id, name, description, price_usd, billing_period, max_payments_monthly, max_merchants, max_api_calls_monthly, features, is_active, created_at, updated_at FROM subscription_plans
WHERE id = $1 AND is_active = true
LIMIT 1
`

func (q *Queries) GetSubscriptionPlanByID(ctx context.Context, id string) (SubscriptionPlan, error) {
	row := q.db.QueryRow(ctx, getSubscriptionPlanByID, id)
	var i SubscriptionPlan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.PriceUsd,
		&i.BillingPeriod,
		&i.MaxPaymentsMonthly,
		&i.MaxMerchants,
		&i.MaxApiCallsMonthly,
		&i.Features,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAllSubscriptionPlans = `-- name: ListAllSubscriptionPlans :many
SELECT id, name, description, price_usd, billing_period, max_payments_monthly, max_merchants, max_api_calls_monthly, features, is_active, created_at, updated_at FROM subscription_plans
ORDER BY price_usd ASC
`

func (q *Queries) ListAllSubscriptionPlans(ctx context.Context) ([]SubscriptionPlan, error) {
	rows, err := q.db.Query(ctx, listAllSubscriptionPlans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubscriptionPlan
	for rows.Next() {
		var i SubscriptionPlan
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.PriceUsd,
			&i.BillingPeriod,
			&i.MaxPaymentsMonthly,
			&i.MaxMerchants,
			&i.MaxApiCallsMonthly,
			&i.Features,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionPlans = `-- name: ListSubscriptionPlans :many
SELECT id, name, description, price_usd, billing_period, max_payments_monthly, max_merchants, max_api_calls_monthly, features, is_active, created_at, updated_at FROM subscription_plans
WHERE is_active = true
ORDER BY price_usd ASC
`

func (q *Queries) ListSubscriptionPlans(ctx context.Context) ([]SubscriptionPlan, error) {
	rows, err := q.db.Query(ctx, listSubscriptionPlans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubscriptionPlan
	for rows.Next() {
		var i SubscriptionPlan
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.PriceUsd,
			&i.BillingPeriod,
			&i.MaxPaymentsMonthly,
			&i.MaxMerchants,
			&i.MaxApiCallsMonthly,
			&i.Features,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubscriptionPlan = `-- name: UpdateSubscriptionPlan :exec
UPDATE subscription_plans
SET
    name = $2,
    description = $3,
    price_usd = $4,
    max_payments_monthly = $5,
    max_merchants = $6,
    max_api_calls_monthly = $7,
    features = $8,
    is_active = $9,
    updated_at = NOW()
WHERE id = $1
`

type UpdateSubscriptionPlanParams struct {
	ID                 string
	Name               string
	Description        sql.NullString
	PriceUsd           pgtype.Numeric
	MaxPaymentsMonthly sql.NullInt32
	MaxMerchants       sql.NullInt32
	MaxApiCallsMonthly sql.NullInt32
	Features           pgtype.JSONB
	IsActive           sql.NullBool
}

func (q *Queries) UpdateSubscriptionPlan(ctx context.Context, arg UpdateSubscriptionPlanParams) error {
	_, err := q.db.Exec(ctx, updateSubscriptionPlan,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.PriceUsd,
		arg.MaxPaymentsMonthly,
		arg.MaxMerchants,
		arg.MaxApiCallsMonthly,
		arg.Features,
		arg.IsActive,
	)
	return err
}
