// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: derived_addresses.sql

package repository

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const countUnusedAddresses = `-- name: CountUnusedAddresses :one
SELECT COUNT(*) FROM derived_addresses
WHERE xpub_wallet_id = $1 AND is_used = false
`

func (q *Queries) CountUnusedAddresses(ctx context.Context, xpubWalletID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countUnusedAddresses, xpubWalletID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDerivedAddress = `-- name: CreateDerivedAddress :one
INSERT INTO derived_addresses (
    uuid, xpub_wallet_id, merchant_id, blockchain,
    address, derivation_path, derivation_index, public_key,
    is_used, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, uuid, xpub_wallet_id, merchant_id, blockchain, address, derivation_path, derivation_index, public_key, is_used, payment_id, tatum_mainnet_subscription_id, tatum_testnet_subscription_id, created_at, updated_at
`

type CreateDerivedAddressParams struct {
	Uuid            uuid.UUID
	XpubWalletID    int64
	MerchantID      int64
	Blockchain      string
	Address         string
	DerivationPath  string
	DerivationIndex int32
	PublicKey       sql.NullString
	IsUsed          sql.NullBool
	CreatedAt       time.Time
	UpdatedAt       time.Time
}

func (q *Queries) CreateDerivedAddress(ctx context.Context, arg CreateDerivedAddressParams) (DerivedAddress, error) {
	row := q.db.QueryRow(ctx, createDerivedAddress,
		arg.Uuid,
		arg.XpubWalletID,
		arg.MerchantID,
		arg.Blockchain,
		arg.Address,
		arg.DerivationPath,
		arg.DerivationIndex,
		arg.PublicKey,
		arg.IsUsed,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i DerivedAddress
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.XpubWalletID,
		&i.MerchantID,
		&i.Blockchain,
		&i.Address,
		&i.DerivationPath,
		&i.DerivationIndex,
		&i.PublicKey,
		&i.IsUsed,
		&i.PaymentID,
		&i.TatumMainnetSubscriptionID,
		&i.TatumTestnetSubscriptionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDerivedAddressByAddress = `-- name: GetDerivedAddressByAddress :one
SELECT id, uuid, xpub_wallet_id, merchant_id, blockchain, address, derivation_path, derivation_index, public_key, is_used, payment_id, tatum_mainnet_subscription_id, tatum_testnet_subscription_id, created_at, updated_at FROM derived_addresses
WHERE blockchain = $1 AND address = $2
LIMIT 1
`

type GetDerivedAddressByAddressParams struct {
	Blockchain string
	Address    string
}

func (q *Queries) GetDerivedAddressByAddress(ctx context.Context, arg GetDerivedAddressByAddressParams) (DerivedAddress, error) {
	row := q.db.QueryRow(ctx, getDerivedAddressByAddress, arg.Blockchain, arg.Address)
	var i DerivedAddress
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.XpubWalletID,
		&i.MerchantID,
		&i.Blockchain,
		&i.Address,
		&i.DerivationPath,
		&i.DerivationIndex,
		&i.PublicKey,
		&i.IsUsed,
		&i.PaymentID,
		&i.TatumMainnetSubscriptionID,
		&i.TatumTestnetSubscriptionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDerivedAddressByID = `-- name: GetDerivedAddressByID :one
SELECT id, uuid, xpub_wallet_id, merchant_id, blockchain, address, derivation_path, derivation_index, public_key, is_used, payment_id, tatum_mainnet_subscription_id, tatum_testnet_subscription_id, created_at, updated_at FROM derived_addresses WHERE id = $1 LIMIT 1
`

func (q *Queries) GetDerivedAddressByID(ctx context.Context, id int64) (DerivedAddress, error) {
	row := q.db.QueryRow(ctx, getDerivedAddressByID, id)
	var i DerivedAddress
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.XpubWalletID,
		&i.MerchantID,
		&i.Blockchain,
		&i.Address,
		&i.DerivationPath,
		&i.DerivationIndex,
		&i.PublicKey,
		&i.IsUsed,
		&i.PaymentID,
		&i.TatumMainnetSubscriptionID,
		&i.TatumTestnetSubscriptionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDerivedAddressByUUID = `-- name: GetDerivedAddressByUUID :one
SELECT id, uuid, xpub_wallet_id, merchant_id, blockchain, address, derivation_path, derivation_index, public_key, is_used, payment_id, tatum_mainnet_subscription_id, tatum_testnet_subscription_id, created_at, updated_at FROM derived_addresses WHERE uuid = $1 LIMIT 1
`

func (q *Queries) GetDerivedAddressByUUID(ctx context.Context, argUuid uuid.UUID) (DerivedAddress, error) {
	row := q.db.QueryRow(ctx, getDerivedAddressByUUID, argUuid)
	var i DerivedAddress
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.XpubWalletID,
		&i.MerchantID,
		&i.Blockchain,
		&i.Address,
		&i.DerivationPath,
		&i.DerivationIndex,
		&i.PublicKey,
		&i.IsUsed,
		&i.PaymentID,
		&i.TatumMainnetSubscriptionID,
		&i.TatumTestnetSubscriptionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLastDerivedIndex = `-- name: GetLastDerivedIndex :one
SELECT COALESCE(MAX(derivation_index), -1) as last_index
FROM derived_addresses
WHERE xpub_wallet_id = $1
`

func (q *Queries) GetLastDerivedIndex(ctx context.Context, xpubWalletID int64) (interface{}, error) {
	row := q.db.QueryRow(ctx, getLastDerivedIndex, xpubWalletID)
	var last_index interface{}
	err := row.Scan(&last_index)
	return last_index, err
}

const getNextUnusedAddress = `-- name: GetNextUnusedAddress :one
SELECT id, uuid, xpub_wallet_id, merchant_id, blockchain, address, derivation_path, derivation_index, public_key, is_used, payment_id, tatum_mainnet_subscription_id, tatum_testnet_subscription_id, created_at, updated_at FROM derived_addresses
WHERE xpub_wallet_id = $1 AND is_used = false
ORDER BY derivation_index ASC
LIMIT 1
`

func (q *Queries) GetNextUnusedAddress(ctx context.Context, xpubWalletID int64) (DerivedAddress, error) {
	row := q.db.QueryRow(ctx, getNextUnusedAddress, xpubWalletID)
	var i DerivedAddress
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.XpubWalletID,
		&i.MerchantID,
		&i.Blockchain,
		&i.Address,
		&i.DerivationPath,
		&i.DerivationIndex,
		&i.PublicKey,
		&i.IsUsed,
		&i.PaymentID,
		&i.TatumMainnetSubscriptionID,
		&i.TatumTestnetSubscriptionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listDerivedAddressesByMerchantID = `-- name: ListDerivedAddressesByMerchantID :many
SELECT id, uuid, xpub_wallet_id, merchant_id, blockchain, address, derivation_path, derivation_index, public_key, is_used, payment_id, tatum_mainnet_subscription_id, tatum_testnet_subscription_id, created_at, updated_at FROM derived_addresses
WHERE merchant_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListDerivedAddressesByMerchantID(ctx context.Context, merchantID int64) ([]DerivedAddress, error) {
	rows, err := q.db.Query(ctx, listDerivedAddressesByMerchantID, merchantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DerivedAddress
	for rows.Next() {
		var i DerivedAddress
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.XpubWalletID,
			&i.MerchantID,
			&i.Blockchain,
			&i.Address,
			&i.DerivationPath,
			&i.DerivationIndex,
			&i.PublicKey,
			&i.IsUsed,
			&i.PaymentID,
			&i.TatumMainnetSubscriptionID,
			&i.TatumTestnetSubscriptionID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDerivedAddressesByWalletID = `-- name: ListDerivedAddressesByWalletID :many
SELECT id, uuid, xpub_wallet_id, merchant_id, blockchain, address, derivation_path, derivation_index, public_key, is_used, payment_id, tatum_mainnet_subscription_id, tatum_testnet_subscription_id, created_at, updated_at FROM derived_addresses
WHERE xpub_wallet_id = $1
ORDER BY derivation_index ASC
`

func (q *Queries) ListDerivedAddressesByWalletID(ctx context.Context, xpubWalletID int64) ([]DerivedAddress, error) {
	rows, err := q.db.Query(ctx, listDerivedAddressesByWalletID, xpubWalletID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DerivedAddress
	for rows.Next() {
		var i DerivedAddress
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.XpubWalletID,
			&i.MerchantID,
			&i.Blockchain,
			&i.Address,
			&i.DerivationPath,
			&i.DerivationIndex,
			&i.PublicKey,
			&i.IsUsed,
			&i.PaymentID,
			&i.TatumMainnetSubscriptionID,
			&i.TatumTestnetSubscriptionID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAddressAsUsed = `-- name: MarkAddressAsUsed :one
UPDATE derived_addresses
SET is_used = true, payment_id = $2, updated_at = $3
WHERE id = $1
RETURNING id, uuid, xpub_wallet_id, merchant_id, blockchain, address, derivation_path, derivation_index, public_key, is_used, payment_id, tatum_mainnet_subscription_id, tatum_testnet_subscription_id, created_at, updated_at
`

type MarkAddressAsUsedParams struct {
	ID        int64
	PaymentID sql.NullInt64
	UpdatedAt time.Time
}

func (q *Queries) MarkAddressAsUsed(ctx context.Context, arg MarkAddressAsUsedParams) (DerivedAddress, error) {
	row := q.db.QueryRow(ctx, markAddressAsUsed, arg.ID, arg.PaymentID, arg.UpdatedAt)
	var i DerivedAddress
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.XpubWalletID,
		&i.MerchantID,
		&i.Blockchain,
		&i.Address,
		&i.DerivationPath,
		&i.DerivationIndex,
		&i.PublicKey,
		&i.IsUsed,
		&i.PaymentID,
		&i.TatumMainnetSubscriptionID,
		&i.TatumTestnetSubscriptionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateDerivedAddressTatumSubscription = `-- name: UpdateDerivedAddressTatumSubscription :one
UPDATE derived_addresses
SET tatum_mainnet_subscription_id = $2, tatum_testnet_subscription_id = $3, updated_at = $4
WHERE id = $1
RETURNING id, uuid, xpub_wallet_id, merchant_id, blockchain, address, derivation_path, derivation_index, public_key, is_used, payment_id, tatum_mainnet_subscription_id, tatum_testnet_subscription_id, created_at, updated_at
`

type UpdateDerivedAddressTatumSubscriptionParams struct {
	ID                         int64
	TatumMainnetSubscriptionID sql.NullString
	TatumTestnetSubscriptionID sql.NullString
	UpdatedAt                  time.Time
}

func (q *Queries) UpdateDerivedAddressTatumSubscription(ctx context.Context, arg UpdateDerivedAddressTatumSubscriptionParams) (DerivedAddress, error) {
	row := q.db.QueryRow(ctx, updateDerivedAddressTatumSubscription,
		arg.ID,
		arg.TatumMainnetSubscriptionID,
		arg.TatumTestnetSubscriptionID,
		arg.UpdatedAt,
	)
	var i DerivedAddress
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.XpubWalletID,
		&i.MerchantID,
		&i.Blockchain,
		&i.Address,
		&i.DerivationPath,
		&i.DerivationIndex,
		&i.PublicKey,
		&i.IsUsed,
		&i.PaymentID,
		&i.TatumMainnetSubscriptionID,
		&i.TatumTestnetSubscriptionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
